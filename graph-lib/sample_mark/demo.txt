struct Node {
  int  m;
  struct Node * l;
  struct Node * r;
};

void mark(struct Node * x) {
  struct Node * l, * r;
  int root_mark;
  if (x == 0)
    return;
  root_mark = x -> m;
  if (root_mark == 1)
    return;
  l = x -> l;
  r = x -> r;
  x -> m = 1;
  mark(l);
  mark(r);
}

























{graph g x}
  mark(x);
{exists g', mark g x g' /\ graph g' x}













The most important part:

Given:
  (1) unmarked g x
  (2) x is not null
  (3) g(x) = (0, l, r)

{graph g x}

  l = x -> l;
  r = x -> r;
  x -> m = 1;
  mark(l);
  mark(r);

{exists g', mark g x g' /\ graph g' x}
















Given:
  (1) unmarked g x
  (2) x is not null
  (3) g(x) = (0, l, r)

{ graph g x }

  l = x -> l;
  r = x -> r;
  x -> m = 1;

{ graph g[(1, l, r) / x] x                                                   /\ [l] = l /\ [r] = r }
  [let g1 := g[(1, l, r) / x]]
{ graph g1 x /\ mark1 g x g1                                        /\ [l] = l /\ [r] = r }

  mark(l);

{ exists g2, graph g2 x /\ mark g1 l g2                         /\ mark1 g x g1 /\ [l] = l /\ [r] = r }
  [intro g2]
{ graph g2 x                                                                   /\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }

  mark(r);

{ exists g3, graph g3 x /\ mark g2 r g3                         /\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }
  [intro g3]
{ graph g3 x                                                                   /\ mark g2 r g3/\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }
  [Math]
{ graph g3 x                                                                   /\ mark g x g3 }
  [Math Again]
{ exists g', graph g' x /\ mark g x g' }
























Definition mark1 (g1 : Graph) (n : V) (g2 : Graph) : Prop :=
  g1 ~=~ g2 /\
  vvalid g1 n /\
  marked g2 n /\
  forall n', n <> n' -> (marked g1 n' <-> marked g2 n').

Definition mark (g1 : Graph) (root : V) (g2 : Graph) : Prop :=
  g1 ~=~ g2 /\
  (forall n, g1 |= root ~o~> n satisfying (unmarked g1) -> marked g2 n) /\
  (forall n, ~ g1 |= root ~o~> n satisfying (unmarked g1) -> (marked g1 n <-> marked g2 n)).























{ graph g x }
  l = x -> l;
  r = x -> r;
  x -> m = 1;
{ graph g[(1, l, r) / x] x /\ [l] = l /\ [r] = r }



Given:
  (1) unmarked g x
  (2) x is not null
  (3) g(x) = (0, l, r)

Step 1: Symbolic execution

  { x |--> (0, l, r) }
   
    l = x -> l;
   
  { x |--> (0, l, r) /\ [l] = l }
   
    r = x -> r;
   
  { x |--> (0, l, r) /\ [l] = l /\ [r] = r }
   
    x -> m = 1;
   
  { x |--> (1, l, r) /\ [l] = l /\ [r] = r }


Step 2:

{ x |--> (0, l, r) }  ... ...  { x |--> (1, l, r) /\ [l] = l /\ [r] = r }
============================================== [Frame Rule]
       { graph g x }  ... ...  { graph g[(1, l, r) / x] x /\ [l] = l /\ [r] = r }



























Given:
  (1) unmarked g x
  (2) x is not null
  (3) g(x) = (0, l, r)


{ graph g x }

 [localize] ----  {x |--> (0, l, r) }
     
                          l = x -> l;
                       
                        { x |--> (0, l, r) /\ [l] = l }
                         
                          r = x -> r;
                         
                        { x |--> (0, l, r) /\ [l] = l /\ [r] = r }
                         
                          x -> m = 1;
           
 [unlocalize] --  { x |--> (1, l, r) /\ [l] = l /\ [r] = r }

{ graph g[(1, l, r) / x] x /\ [l] = l /\ [r] = r }

  [let g1 := g[(1, l, r) / x]]

{ graph g1 x /\ mark1 g x g1/\ [l] = l /\ [r] = r }

=================================================







Well, the rest part of the proof is still hard to read.






=================================================

{ graph g1 x /\ mark1 g x g1/\ [l] = l /\ [r] = r }

 [localize] ----  { graph g1 l /\ [l] = l}

                          mark(l);

 [unlocalize] --  { exists g2, graph g2 l /\ mark g1 l g2 /\ [l] = l}

{ exists g2, graph g2 x /\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }

  [intro g2]

{ graph g2 x /\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }

 [localize] ----  { graph g2 r /\ [r] = r}

                          mark(r);

 [unlocalize] --  { exists g3, graph g3 r /\ mark g2 l g3 /\ [r] = r}

{ exists g3, graph g3 x /\ mark g2 r g3 /\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }

  [intro g3]

{ graph g3 x /\ mark g2 r g3/\ mark g1 l g2 /\ mark1 g x g1 /\ [l] = l /\ [r] = r }

  [Math]

{ exists g', graph g' x /\ mark g x g' }


=================================================







But, proof carried code will be easier to write, given [localize] and [unlocalize].






=================================================
